\section{Scaling Distributed Systems}

In practical applications, clusters of varying sizes are required. In some cases many nodes will be used, each replicating a small piece of data many times over. While in others, few nodes wil are used and larger chunks of data are replicated. Though in implementation, there are drawbacks to having a cluster with many nodes. As you continue to increase node number, various factors can lower a networks required time to reach consensus. Raft solves the consensus problem algorithmically, but let's, for example, take a look at a real world example where scaling comes into play.

We can imagine a large party of friends trying to decide where they want to go to eat for dinner. In this scenario in order to make an effective, and satisfying decision as to where the group should dine, each member of the group must be consulted. So the time in which it takes the entire group to come to an agreement increases as the size of the group increases.

In this large party, many more people will have to be consulted, and more options will have to be weighed before a choice is made. Though, compare this to just a few friends, who would be able to reach mutual agreement much faster, as they have less to consider, and fewer people that need to be taken into account before reaching a decision.

This principle is clearly demonstrated in distributed systems \cite{NeumanScaling}. Adding more nodes to a cluster makes it more difficult for the network to handle faults and replicate its state. Demonstrated in Raft, the more \textit{followers} in a system, the more heartbeats that have to be sent out by the \textit{leader}, processed, responded to, and then confirmed \cite{OngaroRaft}.


\subsection{Applications in Raft}

Like all other algorithms of its class, Raft has similar problems scaling. Though it has a distrinctly unique set of problems. It should be noted that we can consider Raft generally \textit{synchronous}. That is all nodes must reach a \textit{univalent} state, before handling the replication of the next update to the log. Raft's use of a \textit{leader}, requires all changes to the network state be processed through a single node, thereby essentially creating a synchronous cluster where in which \textit{followers} have very little power to influence the cluster's state where there is a healthy \textit{leader}. So when we discuss scaling in terms of a leader based methods we have to examine different properities of the algorithm.